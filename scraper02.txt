// package main

// import (
// 	"encoding/csv"
// 	"encoding/json"
// 	"fmt"
// 	"io/ioutil"
// 	"log"
// 	"net/http"
// 	"os"
// 	"sync"
// )

// type Metadata struct {
// 	Image       string `json:"image"`
// 	Description string `json:"description"`
// 	Name        string `json:"name"`
// }

// func readCIDsFromFile(filePath string) ([]string, error) {
// 	file, err := os.Open(filePath)
// 	if err != nil {
// 		return nil, err
// 	}
// 	defer file.Close()

// 	reader := csv.NewReader(file)
// 	lines, err := reader.ReadAll()
// 	if err != nil {
// 		return nil, err
// 	}

// 	var cids []string
// 	for _, line := range lines {
// 		cids = append(cids, line[0]) // Assuming CID is in the first column
// 	}
// 	return cids, nil
// }

// func fetchAndParseMetadata(cid string) {
// 	url := fmt.Sprintf("https://ipfs.io/ipfs/%s", cid)
// 	resp, err := http.Get(url)
// 	if err != nil {
// 		log.Printf("Error fetching metadata for CID %s: %v", cid, err)
// 		return
// 	}
// 	defer resp.Body.Close()

// 	body, err := ioutil.ReadAll(resp.Body)
// 	if err != nil {
// 		log.Printf("Error reading response for CID %s: %v", cid, err)
// 		return
// 	}

// 	var metadata Metadata
// 	if !json.Valid(body) {
// 		log.Printf("Invalid JSON for CID %s: %s", cid, string(body))
// 		return
// 	}
// 	if err := json.Unmarshal(body, &metadata); err != nil {
// 		log.Printf("Error parsing metadata for CID %s: %v", cid, err)
// 		log.Printf("Response body: %s", string(body))
// 		return
// 	}

// 	// fmt.Printf("\nName: %s\n Description: %s\n Image: %s\n", metadata.Name, metadata.Description, metadata.Image)
// }

// func worker(cidChan <-chan string, wg *sync.WaitGroup) {
// 	for cid := range cidChan {
// 		fetchAndParseMetadata(cid)
// 		wg.Done()
// 	}
// }

// func main() {
// 	cids, err := readCIDsFromFile("ipfs_cids.csv")
// 	if err != nil {
// 		log.Fatalf("Error reading CSV: %v", err)
// 	}

// 	const numWorkers = 10 // adjust as needed
// 	cidChan := make(chan string)
// 	var wg sync.WaitGroup

// 	// Start workers
// 	for i := 0; i < numWorkers; i++ {
// 		go worker(cidChan, &wg)
// 	}

// 	// Send CIDs to workers
// 	for _, cid := range cids {
// 		wg.Add(1)
// 		cidChan <- cid
// 	}
// 	close(cidChan) // close the channel when all CIDs have been sent

// 	// Wait for all metadata to be fetched
// 	wg.Wait()
// }

package main

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"sync"

	_ "github.com/lib/pq"
)

type Metadata struct {
	Image       string `json:"image"`
	Description string `json:"description"`
	Name        string `json:"name"`
}

func readCIDsFromFile(filePath string) ([]string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	reader := csv.NewReader(file)
	lines, err := reader.ReadAll()
	if err != nil {
		return nil, err
	}

	var cids []string
	for _, line := range lines {
		cids = append(cids, line[0]) // Assuming CID is in the first column
	}
	return cids, nil
}

func connectToDB() (*sql.DB, error) {
	connStr := "user=postgres password=example dbname=postgres sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return nil, err
	}
	return db, nil
}

func storeMetadata(db *sql.DB, metadata Metadata) error {
	sqlStatement := `
        INSERT INTO metadata (image, description, name)
        VALUES ($1, $2, $3)`
	_, err := db.Exec(sqlStatement, metadata.Image, metadata.Description, metadata.Name)
	return err
}

func fetchAndParseMetadata(db *sql.DB, cid string) {
	url := fmt.Sprintf("https://ipfs.io/ipfs/%s", cid)
	resp, err := http.Get(url)
	if err != nil {
		log.Printf("Error fetching metadata for CID %s: %v", cid, err)
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Printf("Error reading response for CID %s: %v", cid, err)
		return
	}

	var metadata Metadata
	if !json.Valid(body) {
		log.Printf("Invalid JSON for CID %s: %s", cid, string(body))
		return
	}
	if err := json.Unmarshal(body, &metadata); err != nil {
		log.Printf("Error parsing metadata for CID %s: %v", cid, err)

		// NOTE: The response body log below kept returning invalid json in html that looked like this:
		/*
					 <section class="container">
			            <p>
			                Your request is invalid. Most probably, the CID (the part after <code>/ipfs/</code>) is incorrect.
			            </p>
			            <p>How you can proceed:</p>
			<ul>
			    <li>Verify the URL and try again.</li>
			    <li>Self-host and run an <a
			            href="https://docs.ipfs.tech/concepts/ipfs-implementations/?utm_source=bifrost&utm_medium=ipfsio&utm_campaign=error_pages"
			            rel="noopener noreferrer">IPFS client</a> that verifies your data.</li>
			    <li>Try diagnosing your request with the <a
			            href="https://docs.ipfs.tech/reference/diagnostic-tools/?utm_source=bifrost&utm_medium=ipfsio&utm_campaign=error_pages"
			            rel="noopener noreferrer">IPFS diagnostic tools</a>.</li>
			    <li>Inspect the <a href="https://cid.ipfs.tech/?utm_source=bifrost&utm_medium=ipfsio&utm_campaign=error_pages"
			            rel="noopener noreferrer">CID</a> or <a
			            href="https://explore.ipld.io/?utm_source=bifrost&utm_medium=ipfsio&utm_campaign=error_pages"
			            rel="noopener noreferrer">DAG</a>.</li>
			</ul>        </section>
		*/

		// log.Printf("Response body: %s", string(body))
		return
	}

	if err := storeMetadata(db, metadata); err != nil {
		log.Printf("Error storing metadata for CID %s: %v", cid, err)
		return
	}
}

func worker(db *sql.DB, cidChan <-chan string, wg *sync.WaitGroup) {
	for cid := range cidChan {
		fetchAndParseMetadata(db, cid)
		wg.Done()
	}
}

func printMetadata(db *sql.DB) error {
	rows, err := db.Query("SELECT image, description, name FROM metadata")
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var image, description, name string
		if err := rows.Scan(&image, &description, &name); err != nil {
			return err
		}
		fmt.Printf("Image: %s, Description: %s, Name: %s\n", image, description, name)
	}

	return rows.Err()
}

func main() {
	db, err := connectToDB()
	if err != nil {
		log.Fatalf("Error connecting to database: %v", err)
	}
	defer db.Close()

	_, err = db.Exec(`
	CREATE TABLE IF NOT EXISTS metadata (
		id SERIAL PRIMARY KEY,
		image TEXT,
		description TEXT,
		name TEXT
	)
	`)
	if err != nil {
		log.Fatalf("Error creating table: %v", err)
	}

	cids, err := readCIDsFromFile("ipfs_cids.csv")
	if err != nil {
		log.Fatalf("Error reading CSV: %v", err)
	}

	const numWorkers = 10 // adjust as needed
	cidChan := make(chan string)
	var wg sync.WaitGroup

	// Start workers
	for i := 0; i < numWorkers; i++ {
		go worker(db, cidChan, &wg)
	}

	// Send CIDs to workers
	for _, cid := range cids {
		wg.Add(1)
		cidChan <- cid
	}
	close(cidChan) // close the channel when all CIDs have been sent

	// Wait for all metadata to be fetched
	wg.Wait()

	// Print all metadata
	if err := printMetadata(db); err != nil {
		log.Fatalf("Error printing metadata: %v", err)
	}
}
