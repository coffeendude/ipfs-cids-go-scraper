// package main

// import (
// 	"fmt"
// 	"log"
// 	"sync"
// 	"testing"
// )

// func BenchmarkMaxConcurrency(b *testing.B) {
// 	// cids, err := readCIDsFromFile("ipfs_cids.csv")
// 	// if err != nil {
// 	// 	b.Fatal(err)
// 	// }

// 	cids, err := readCIDsFromFile("ipfs_cids.csv")
// 	if err != nil {
// 		log.Fatalf("Error reading CSV: %v", err)
// 	}

// 	for maxConcurrency := 1; maxConcurrency <= 10; maxConcurrency++ { // adjust the range as needed
// 		b.Run(fmt.Sprintf("MaxConcurrency%d", maxConcurrency), func(b *testing.B) {
// 			for i := 0; i < b.N; i++ {
// 				b.StopTimer() // stop timer to ignore setup time
// 				var wg sync.WaitGroup
// 				sem := make(chan struct{}, maxConcurrency)
// 				b.StartTimer() // restart timer to measure the execution time

// 				for _, cid := range cids {
// 					wg.Add(1)
// 					sem <- struct{}{} // will block if there are already maxConcurrency goroutines
// 					go func(cid string) {
// 						defer wg.Done()
// 						defer func() { <-sem }() // release a spot when this goroutine finishes
// 						fetchAndParseMetadata(cid, &wg)
// 					}(cid)
// 				}

// 				wg.Wait()
// 			}
// 		})
// 	}
// }
